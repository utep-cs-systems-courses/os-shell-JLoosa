import os
from enum import Enum
from typing import Generator

class PacketType(Enum):
    NONE = 0
    TEXT = 1
    FILE = 2

PACKET_MAX_BYTES = 1000  # Limit to 1kb packets per Dr. Freudenthal's instructions
PACKET_DEFAULT_ENCODING = "utf-8"  # Ensure compatibility with most characters
PACKET_BYTES_ORDERING = "big"  # In case we need to use big or little-endian

# Used to split the header into ( Packet Type | Size | Data )
# The packet is encoded using the default encoding.
PACKET_HEADER_DIVISOR = '\u0000'

"""
Network Communication has an input and an output.

The section below is dedicated to network output - that is,
outgoing packets that are generation by this process with
the intent of being sent to a destination.
"""

class NetworkPacketOut:
    """
    Superclass of all TCP/UDP netwroking communication packets.
    """

    def __init__(self, packet_type: PacketType) -> None:
        self._packet_type: PacketType = packet_type
        self._packet_size: int = 0
        self._packet_payload: bytes = None
    
    def prepare(self) -> None:
        """
        Some packets may require additional set-up before sending.
        This function is provided as an optional utility for those
        packets to use to prepare for sending.
        """
        pass

    def get_segmented_data(self) -> Generator[bytes, None, None]:
        """
        This is the generator function that all NetworkPacket
        classes must implement to be able to have its data sent
        over the network. Sent data should be encoded using the
        default packet encoding
        """
        pass

class PacketOutText(NetworkPacketOut):
    """
    This class represents a single text packet.
    The instatiation of this packet will render the text immutable.
    """
    
    def __init__(self, text: str):
        super().__init__(PacketType.TEXT)
        self._packet_payload = text.encode(PACKET_DEFAULT_ENCODING)
        self._packet_size = len(self._packet_payload)
        self._header = "%d%s%d%s" % (self._packet_type.value, PACKET_HEADER_DIVISOR, self._packet_size, PACKET_HEADER_DIVISOR)
    
    def get_segmented_data(self) -> Generator[bytes, None, None]:
        # This is a Generator function so I can yield the header
        # And then yield all of the data
        yield self._header.encode(PACKET_DEFAULT_ENCODING)
        for byterange in range(self._packet_size // PACKET_MAX_BYTES):
            start = byterange * PACKET_MAX_BYTES  # Find the starting point for this segement
            end = min(self._packet_size, (byterange + 1) * PACKET_MAX_BYTES)  # Find the ending point for this segment
            yield self._packet_payload[ start : end ]
    
"""
Network Communication has an input and an output.

The section below is dedicated to network input - that is,
incoming packets that were generated by another process and
sent to this process.
"""

class PacketInReader:
    """
    This class is intended for use by a receiving client
    to accept and decode incoming packets.

    Although polymorphism in this situation may also be
    desirable, I have temporarily forgoed the use of it as
    this networking system is minimalistic enough to allow
    for me to place all of the receiving functionality in
    a single class.
    """

    def __init__(self, file_descriptor_in: int):
        self._file_descriptor_in: int = file_descriptor_in
        self._packet_type: PacketType = PacketType.NONE
        self._bytes_remaining: int = 0
        self._internal_buffer: List[str] = None

    def read(self):
        # Read an unknown-length header if we do not have a packet type
        if PacketType is PacketType.NONE:
            header = os.read(PACKET_MAX_BYTES)
            if header:
                header = header.decode(PACKET_DEFAULT_ENCODING)
                # Maxsplit of 2 to divide into the three sections defined near the top of this file
                ptype, plen, pdat = header.split(PACKET_HEADER_DIVISOR, maxsplit=2)
                self._packet_type = PacketType.fromValue(int(ptype))
                self._internal_buffer = [pdat]
                self._bytes_remaining = int(plen) - len(pdat)
        # We have a packet type so we can read normally
        read_buffer = os.read(self._file_descriptor_in, min(PACKET_MAX_BYTES, self._bytes_remaining)
        if self._bytes_remaining > PACKET_MAX_BYTES:
            self._bytes_remaining -= PACKET_MAX_BYTES
        else:
            self._bytes_remaining = 0
            self._packet_type = PacketType.NONE
        self._internal_buffer.append(read_buffer.decode(PACKET_DEFAULT_ENCODING))
